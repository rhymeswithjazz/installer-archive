<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin - Installer Archive</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    :root {
      --bg: #0f0f0f;
      --bg-card: #1a1a1a;
      --bg-hover: #252525;
      --text: #f5f5f5;
      --text-muted: #a0a0a0;
      --border: #333;
      --primary: #6366f1;
      --danger: #ef4444;
      --success: #22c55e;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 20px;
      line-height: 1.5;
    }
    h1 { margin: 0 0 20px; font-size: 1.5rem; }
    .toolbar {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 20px;
      padding: 15px;
      background: var(--bg-card);
      border-radius: 8px;
      align-items: center;
    }
    .toolbar input, .toolbar select {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg);
      color: var(--text);
      font-size: 0.9rem;
    }
    .toolbar input { width: 250px; }
    .toolbar select { min-width: 150px; }
    .toolbar button {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background: var(--primary);
      color: white;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .toolbar button:hover { opacity: 0.9; }
    .toolbar button.danger { background: var(--danger); }
    .stats {
      color: var(--text-muted);
      font-size: 0.85rem;
      margin-left: auto;
    }
    .stats strong { color: var(--text); }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    th {
      background: var(--bg-card);
      position: sticky;
      top: 0;
      font-weight: 600;
    }
    tr:hover { background: var(--bg-hover); }
    tr.selected { background: rgba(99, 102, 241, 0.2); }
    tr.hidden-row { opacity: 0.4; }
    .checkbox-cell { width: 40px; text-align: center; }
    .checkbox-cell input { width: 16px; height: 16px; cursor: pointer; }
    .title-cell { max-width: 300px; }
    .title-cell a {
      color: var(--text);
      text-decoration: none;
    }
    .title-cell a:hover { color: var(--primary); }
    .title-cell .title-text {
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 3px;
    }
    .title-cell .title-text:hover { background: var(--bg-hover); }
    .title-cell input {
      width: 100%;
      padding: 4px 8px;
      border: 1px solid var(--primary);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
      font-size: 0.9rem;
    }
    .title-cell .edit-btn {
      opacity: 0;
      margin-left: 6px;
      padding: 2px 6px;
      font-size: 0.75rem;
      background: var(--bg-hover);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-muted);
      cursor: pointer;
    }
    .title-cell:hover .edit-btn { opacity: 1; }
    .save-indicator {
      margin-left: 8px;
      font-size: 0.7rem;
      color: var(--text-muted);
      font-style: italic;
    }
    .tags-cell { min-width: 150px; }
    .tags-container { display: flex; flex-wrap: wrap; gap: 4px; align-items: center; }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      background: rgba(99, 102, 241, 0.2);
      color: var(--primary);
      border-radius: 12px;
      font-size: 0.75rem;
    }
    .tag .remove-tag {
      cursor: pointer;
      opacity: 0.6;
      font-size: 0.9rem;
      line-height: 1;
    }
    .tag .remove-tag:hover { opacity: 1; }
    .add-tag-btn {
      padding: 2px 8px;
      background: transparent;
      border: 1px dashed var(--border);
      border-radius: 12px;
      color: var(--text-muted);
      font-size: 0.75rem;
      cursor: pointer;
    }
    .add-tag-btn:hover { border-color: var(--primary); color: var(--primary); }
    .tag-input-wrapper {
      position: relative;
      display: inline-block;
    }
    .tag-input {
      padding: 2px 8px;
      border: 1px solid var(--primary);
      border-radius: 12px;
      background: var(--bg);
      color: var(--text);
      font-size: 0.75rem;
      width: 100px;
    }
    .tag-autocomplete {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      max-height: 150px;
      overflow-y: auto;
      z-index: 100;
      margin-top: 2px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .tag-suggestion {
      padding: 6px 10px;
      cursor: pointer;
      font-size: 0.8rem;
    }
    .tag-suggestion:hover, .tag-suggestion.selected {
      background: var(--primary);
      color: white;
    }
    .tag-suggestion-new {
      color: var(--text-muted);
      font-style: italic;
    }
    .url-cell {
      max-width: 200px;
      color: var(--text-muted);
      font-size: 0.8rem;
    }
    .url-cell .url-display {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .url-cell .url-text {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 3px;
    }
    .url-cell .url-text:hover { background: var(--bg-hover); }
    .url-cell input {
      width: 100%;
      padding: 4px 8px;
      border: 1px solid var(--primary);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
      font-size: 0.8rem;
    }
    .url-cell .edit-url-btn {
      opacity: 0;
      padding: 2px 6px;
      font-size: 0.7rem;
      background: var(--bg-hover);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-muted);
      cursor: pointer;
      flex-shrink: 0;
    }
    .url-cell:hover .edit-url-btn { opacity: 1; }
    .dead-link { text-decoration: line-through; opacity: 0.5; }
    .dead-badge {
      display: inline-block;
      padding: 1px 5px;
      background: var(--danger);
      color: white;
      border-radius: 3px;
      font-size: 0.65rem;
      font-weight: 600;
      margin-left: 4px;
    }
    .category-cell select {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
      font-size: 0.85rem;
      cursor: pointer;
    }
    .category-cell select:focus {
      outline: none;
      border-color: var(--primary);
    }
    .actions-cell { white-space: nowrap; }
    .actions-cell button {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      margin-right: 4px;
    }
    .btn-hide { background: var(--danger); color: white; }
    .btn-restore { background: var(--success); color: white; }
    .issue-cell {
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-size: 0.85rem;
      color: var(--text-muted);
    }
    .bulk-actions {
      display: none;
      padding: 10px 15px;
      background: var(--primary);
      border-radius: 6px;
      align-items: center;
      gap: 10px;
    }
    .bulk-actions.visible { display: flex; }
    .bulk-actions select, .bulk-actions button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .bulk-actions select { background: white; color: #333; }
    .bulk-actions button { background: white; color: var(--primary); cursor: pointer; }
    .loading {
      text-align: center;
      padding: 40px;
      color: var(--text-muted);
    }
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      background: var(--success);
      color: white;
      border-radius: 6px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .toast.visible { opacity: 1; }
  </style>
</head>
<body>
  <h1>Installer Archive Admin</h1>

  <div class="toolbar">
    <input type="text" id="search" placeholder="Search titles, URLs...">
    <select id="category-filter">
      <option value="">All Categories</option>
      <option value="apps">Apps</option>
      <option value="shows">Shows</option>
      <option value="movies">Movies</option>
      <option value="games">Games</option>
      <option value="books">Books</option>
      <option value="videos">Videos</option>
      <option value="music">Music</option>
      <option value="podcasts">Podcasts</option>
      <option value="articles">Articles</option>
      <option value="gadgets">Gadgets</option>
    </select>
    <select id="issue-filter">
      <option value="">All Issues</option>
    </select>
    <select id="tag-filter">
      <option value="">All Tags</option>
    </select>
    <label style="color: var(--text-muted); font-size: 0.85rem;">
      <input type="checkbox" id="show-hidden"> Show hidden
    </label>
    <label style="color: var(--text-muted); font-size: 0.85rem;">
      <input type="checkbox" id="show-dead-only"> Dead only
    </label>

    <div class="bulk-actions" id="bulk-actions">
      <span id="selected-count">0 selected</span>
      <select id="bulk-category">
        <option value="">Set category...</option>
        <option value="apps">Apps</option>
        <option value="shows">Shows</option>
        <option value="movies">Movies</option>
        <option value="games">Games</option>
        <option value="books">Books</option>
        <option value="videos">Videos</option>
        <option value="music">Music</option>
        <option value="podcasts">Podcasts</option>
        <option value="articles">Articles</option>
        <option value="gadgets">Gadgets</option>
      </select>
      <button id="bulk-apply">Apply</button>
      <button id="bulk-hide" class="danger">Hide</button>
    </div>

    <div class="stats" id="stats">Loading...</div>
  </div>

  <table>
    <thead>
      <tr>
        <th class="checkbox-cell"><input type="checkbox" id="select-all"></th>
        <th>Title</th>
        <th>URL</th>
        <th>Category</th>
        <th>Tags</th>
        <th>Issue</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="table-body">
      <tr><td colspan="7" class="loading">Loading recommendations...</td></tr>
    </tbody>
  </table>

  <div class="toast" id="toast">Saved!</div>

  <script>
    const CATEGORIES = ['apps', 'shows', 'movies', 'games', 'books', 'videos', 'music', 'podcasts', 'articles', 'gadgets'];
    let recommendations = [];
    let issues = [];
    let selectedIds = new Set();

    // DOM elements
    const searchInput = document.getElementById('search');
    const categoryFilter = document.getElementById('category-filter');
    const issueFilter = document.getElementById('issue-filter');
    const tagFilter = document.getElementById('tag-filter');
    const showHidden = document.getElementById('show-hidden');
    const showDeadOnly = document.getElementById('show-dead-only');
    const tableBody = document.getElementById('table-body');
    const selectAll = document.getElementById('select-all');
    const bulkActions = document.getElementById('bulk-actions');
    const selectedCount = document.getElementById('selected-count');
    const bulkCategory = document.getElementById('bulk-category');
    const stats = document.getElementById('stats');
    const toast = document.getElementById('toast');

    // Load data
    async function loadData() {
      const [recsRes, issuesRes, statsRes] = await Promise.all([
        fetch('/api/recommendations'),
        fetch('/api/issues'),
        fetch('/api/stats')
      ]);

      const recsData = await recsRes.json();
      recommendations = recsData.recommendations;
      issues = await issuesRes.json();
      const statsData = await statsRes.json();

      // Populate issue filter
      issues.sort((a, b) => (b.date || '').localeCompare(a.date || ''));
      issues.forEach(issue => {
        const opt = document.createElement('option');
        opt.value = issue.id;
        opt.textContent = truncate(issue.title, 40);
        issueFilter.appendChild(opt);
      });

      stats.innerHTML = `<strong>${statsData.visibleRecommendations}</strong> visible / <strong>${statsData.totalRecommendations}</strong> total`;

      // Populate tag filter
      updateTagFilter();

      renderTable();
    }

    // Update tag filter dropdown
    function updateTagFilter() {
      const currentValue = tagFilter.value;
      const allTags = new Set();
      recommendations.forEach(rec => {
        (rec.tags || []).forEach(tag => allTags.add(tag));
      });

      tagFilter.innerHTML = '<option value="">All Tags</option>';
      [...allTags].sort().forEach(tag => {
        const opt = document.createElement('option');
        opt.value = tag;
        opt.textContent = tag;
        if (tag === currentValue) opt.selected = true;
        tagFilter.appendChild(opt);
      });
    }

    // Render table
    function renderTable() {
      const search = searchInput.value.toLowerCase();
      const category = categoryFilter.value;
      const issueId = issueFilter.value;
      const tag = tagFilter.value;
      const showHiddenItems = showHidden.checked;
      const deadOnly = showDeadOnly.checked;

      let filtered = recommendations.filter(rec => {
        if (!showHiddenItems && rec.hidden) return false;
        if (deadOnly && !rec.dead) return false;
        if (category && rec.category !== category) return false;
        if (issueId && rec.issueId != issueId) return false;
        if (tag && !(rec.tags || []).includes(tag)) return false;
        if (search) {
          const text = `${rec.title || ''} ${rec.url || ''} ${rec.description || ''}`.toLowerCase();
          if (!text.includes(search)) return false;
        }
        return true;
      });

      if (filtered.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="7" class="loading">No recommendations found</td></tr>';
        return;
      }

      tableBody.innerHTML = filtered.map(rec => {
        const issue = issues.find(i => i.id == rec.issueId);
        const isSelected = selectedIds.has(rec.id);
        const domain = rec.url ? extractDomain(rec.url) : '';

        return `
          <tr class="${isSelected ? 'selected' : ''} ${rec.hidden ? 'hidden-row' : ''}" data-id="${rec.id}">
            <td class="checkbox-cell">
              <input type="checkbox" ${isSelected ? 'checked' : ''} onchange="toggleSelect(${rec.id})">
            </td>
            <td class="title-cell" data-id="${rec.id}">
              <span class="title-text" ondblclick="startEditTitle(${rec.id})">${escapeHtml(rec.title || 'Untitled')}</span>
              <button class="edit-btn" onclick="startEditTitle(${rec.id})">edit</button>
              ${rec.url ? `<a href="${escapeHtml(rec.url)}" target="_blank" style="margin-left:6px;font-size:0.75rem;color:var(--text-muted);">open</a>` : ''}
            </td>
            <td class="url-cell" data-id="${rec.id}">
              <div class="url-display">
                <span class="url-text ${rec.dead ? 'dead-link' : ''}" ondblclick="startEditUrl(${rec.id})" title="${escapeHtml(rec.url || '')}">${escapeHtml(domain)}</span>
                ${rec.dead ? '<span class="dead-badge">DEAD</span>' : ''}
                <button class="edit-url-btn" onclick="startEditUrl(${rec.id})">edit</button>
              </div>
            </td>
            <td class="category-cell">
              <select onchange="updateCategory(${rec.id}, this.value)">
                ${CATEGORIES.map(c => `<option value="${c}" ${rec.category === c ? 'selected' : ''}>${c}</option>`).join('')}
              </select>
            </td>
            <td class="tags-cell">
              <div class="tags-container" data-id="${rec.id}">
                ${(rec.tags || []).map(tag => `
                  <span class="tag">
                    ${escapeHtml(tag)}
                    <span class="remove-tag" onclick="removeTag(${rec.id}, '${escapeHtml(tag)}')">&times;</span>
                  </span>
                `).join('')}
                <button class="add-tag-btn" onclick="startAddTag(${rec.id})">+ tag</button>
              </div>
            </td>
            <td class="issue-cell" title="${escapeHtml(issue?.title || '')}">${escapeHtml(truncate(issue?.title || 'Unknown', 30))}</td>
            <td class="actions-cell">
              ${rec.dead
                ? `<button class="btn-restore" onclick="toggleDead(${rec.id}, false)">Alive</button>`
                : `<button class="btn-hide" onclick="toggleDead(${rec.id}, true)" style="background:#f97316;">Dead</button>`
              }
              ${rec.hidden
                ? `<button class="btn-restore" onclick="restoreRec(${rec.id})">Restore</button>`
                : `<button class="btn-hide" onclick="hideRec(${rec.id})">Hide</button>`
              }
            </td>
          </tr>
        `;
      }).join('');
    }

    // Update category
    async function updateCategory(id, category) {
      await fetch(`/api/recommendations/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ category })
      });

      const rec = recommendations.find(r => r.id === id);
      if (rec) rec.category = category;

      showToast('Category updated');
    }

    // Title editing state
    let titleSaveTimers = {};
    let titleLastSaved = {};

    // Start editing title
    function startEditTitle(id) {
      const rec = recommendations.find(r => r.id === id);
      if (!rec) return;

      const cell = document.querySelector(`.title-cell[data-id="${id}"]`);
      if (!cell) return;

      const currentTitle = rec.title || '';
      titleLastSaved[id] = currentTitle;

      cell.innerHTML = `
        <input type="text" value="${escapeHtml(currentTitle)}"
          oninput="debouncedSaveTitle(${id}, this.value)"
          onkeydown="handleTitleKeydown(event, ${id})"
          onblur="finishTitleEdit(${id})"
          autofocus>
        <span class="save-indicator" id="save-indicator-${id}"></span>
      `;
      cell.querySelector('input').focus();
      cell.querySelector('input').select();
    }

    // Debounced save for title
    function debouncedSaveTitle(id, value) {
      // Clear existing timer
      if (titleSaveTimers[id]) {
        clearTimeout(titleSaveTimers[id]);
      }

      // Show saving indicator
      const indicator = document.getElementById(`save-indicator-${id}`);
      if (indicator) indicator.textContent = '';

      // Set new timer
      titleSaveTimers[id] = setTimeout(() => {
        saveTitleAsync(id, value);
      }, 500);
    }

    // Async save title (non-blocking)
    async function saveTitleAsync(id, newTitle) {
      const rec = recommendations.find(r => r.id === id);
      if (!rec) return;

      newTitle = newTitle.trim();
      if (newTitle === titleLastSaved[id]) return;

      const indicator = document.getElementById(`save-indicator-${id}`);
      if (indicator) indicator.textContent = 'saving...';

      await fetch(`/api/recommendations/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: newTitle })
      });

      rec.title = newTitle;
      titleLastSaved[id] = newTitle;

      if (indicator) indicator.textContent = 'saved';
      setTimeout(() => {
        if (indicator) indicator.textContent = '';
      }, 1000);
    }

    // Handle keydown in title input
    function handleTitleKeydown(event, id) {
      if (event.key === 'Enter') {
        event.preventDefault();
        // Cancel debounce and save immediately
        if (titleSaveTimers[id]) clearTimeout(titleSaveTimers[id]);
        saveTitleAsync(id, event.target.value).then(() => renderTable());
      } else if (event.key === 'Escape') {
        if (titleSaveTimers[id]) clearTimeout(titleSaveTimers[id]);
        renderTable();
      }
    }

    // Finish title edit (on blur) - non-blocking
    function finishTitleEdit(id) {
      // Let any pending save complete, then re-render after a short delay
      setTimeout(() => {
        if (titleSaveTimers[id]) {
          // There's a pending save, wait for it
          clearTimeout(titleSaveTimers[id]);
          const input = document.querySelector(`.title-cell[data-id="${id}"] input`);
          if (input) {
            saveTitleAsync(id, input.value).then(() => {
              // Only re-render if we're not in another edit
              if (!document.querySelector(`.title-cell[data-id="${id}"] input`)) {
                renderTable();
              }
            });
          }
        }
      }, 50);
    }

    // Start editing URL
    function startEditUrl(id) {
      const rec = recommendations.find(r => r.id === id);
      if (!rec) return;

      const cell = document.querySelector(`.url-cell[data-id="${id}"]`);
      if (!cell) return;

      const currentUrl = rec.url || '';
      cell.innerHTML = `
        <input type="text" value="${escapeHtml(currentUrl)}"
          onkeydown="handleUrlKeydown(event, ${id})"
          onblur="saveUrl(${id}, this.value)"
          autofocus>
      `;
      cell.querySelector('input').focus();
      cell.querySelector('input').select();
    }

    // Handle keydown in URL input
    function handleUrlKeydown(event, id) {
      if (event.key === 'Enter') {
        event.preventDefault();
        saveUrl(id, event.target.value);
      } else if (event.key === 'Escape') {
        renderTable();
      }
    }

    // Save URL
    async function saveUrl(id, newUrl) {
      const rec = recommendations.find(r => r.id === id);
      if (!rec) return;

      newUrl = newUrl.trim();
      if (newUrl === rec.url) {
        renderTable();
        return;
      }

      await fetch(`/api/recommendations/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url: newUrl })
      });

      rec.url = newUrl;
      renderTable();
      showToast('URL updated');
    }

    // Toggle dead link status
    async function toggleDead(id, dead) {
      await fetch(`/api/recommendations/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ dead })
      });

      const rec = recommendations.find(r => r.id === id);
      if (rec) rec.dead = dead;

      renderTable();
      showToast(dead ? 'Marked as dead' : 'Marked as alive');
    }

    // Get all unique tags
    function getAllTags() {
      const allTags = new Set();
      recommendations.forEach(rec => {
        (rec.tags || []).forEach(tag => allTags.add(tag));
      });
      return [...allTags].sort();
    }

    // Current autocomplete state
    let currentAutocompleteId = null;
    let selectedSuggestionIndex = -1;

    // Start adding a tag
    function startAddTag(id) {
      const container = document.querySelector(`.tags-container[data-id="${id}"]`);
      if (!container) return;

      currentAutocompleteId = id;
      selectedSuggestionIndex = -1;

      const btn = container.querySelector('.add-tag-btn');
      if (btn) {
        btn.outerHTML = `
          <div class="tag-input-wrapper">
            <input type="text" class="tag-input" placeholder="tag..."
              oninput="updateAutocomplete(${id}, this.value)"
              onkeydown="handleTagKeydown(event, ${id})"
              autofocus>
            <div class="tag-autocomplete" id="autocomplete-${id}" style="display:none;"></div>
          </div>
        `;
        const input = container.querySelector('.tag-input');
        input.focus();

        // Close on outside click
        setTimeout(() => {
          document.addEventListener('click', closeAutocompleteOnOutsideClick);
        }, 10);
      }
    }

    // Close autocomplete when clicking outside
    function closeAutocompleteOnOutsideClick(e) {
      if (!e.target.closest('.tag-input-wrapper')) {
        document.removeEventListener('click', closeAutocompleteOnOutsideClick);
        if (currentAutocompleteId !== null) {
          renderTable();
          currentAutocompleteId = null;
        }
      }
    }

    // Update autocomplete suggestions
    function updateAutocomplete(id, value) {
      const dropdown = document.getElementById(`autocomplete-${id}`);
      if (!dropdown) return;

      const query = value.trim().toLowerCase();
      const allTags = getAllTags();
      const rec = recommendations.find(r => r.id === id);
      const existingTags = rec?.tags || [];

      // Filter tags that match and aren't already on this item
      let suggestions = allTags.filter(tag =>
        tag.includes(query) && !existingTags.includes(tag)
      );

      // Limit to top 8
      suggestions = suggestions.slice(0, 8);

      selectedSuggestionIndex = -1;

      if (suggestions.length === 0 && query.length === 0) {
        // Show all available tags when empty
        suggestions = allTags.filter(tag => !existingTags.includes(tag)).slice(0, 8);
      }

      if (suggestions.length === 0 && query.length > 0) {
        // Show "create new" option
        dropdown.innerHTML = `
          <div class="tag-suggestion tag-suggestion-new" onclick="addTag(${id}, '${escapeHtml(query)}')"
               onmousedown="event.preventDefault()">
            Create "${escapeHtml(query)}"
          </div>
        `;
        dropdown.style.display = 'block';
      } else if (suggestions.length > 0) {
        const showCreateNew = query.length > 0 && !suggestions.includes(query);
        dropdown.innerHTML = suggestions.map((tag, i) => `
          <div class="tag-suggestion" data-index="${i}"
               onclick="addTag(${id}, '${escapeHtml(tag)}')"
               onmousedown="event.preventDefault()">
            ${escapeHtml(tag)}
          </div>
        `).join('') + (showCreateNew ? `
          <div class="tag-suggestion tag-suggestion-new" data-index="${suggestions.length}"
               onclick="addTag(${id}, '${escapeHtml(query)}')"
               onmousedown="event.preventDefault()">
            Create "${escapeHtml(query)}"
          </div>
        ` : '');
        dropdown.style.display = 'block';
      } else {
        dropdown.style.display = 'none';
      }
    }

    // Handle keydown in tag input
    function handleTagKeydown(event, id) {
      const dropdown = document.getElementById(`autocomplete-${id}`);
      const suggestions = dropdown?.querySelectorAll('.tag-suggestion') || [];

      if (event.key === 'ArrowDown') {
        event.preventDefault();
        selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestions.length - 1);
        updateSuggestionSelection(suggestions);
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
        updateSuggestionSelection(suggestions);
      } else if (event.key === 'Enter') {
        event.preventDefault();
        if (selectedSuggestionIndex >= 0 && suggestions[selectedSuggestionIndex]) {
          suggestions[selectedSuggestionIndex].click();
        } else {
          const tag = event.target.value.trim().toLowerCase();
          if (tag) {
            addTag(id, tag);
          } else {
            renderTable();
          }
        }
      } else if (event.key === 'Escape') {
        document.removeEventListener('click', closeAutocompleteOnOutsideClick);
        currentAutocompleteId = null;
        renderTable();
      } else if (event.key === 'Tab' && suggestions.length > 0) {
        event.preventDefault();
        if (selectedSuggestionIndex >= 0) {
          suggestions[selectedSuggestionIndex].click();
        } else if (suggestions[0]) {
          suggestions[0].click();
        }
      }
    }

    // Update visual selection
    function updateSuggestionSelection(suggestions) {
      suggestions.forEach((el, i) => {
        el.classList.toggle('selected', i === selectedSuggestionIndex);
      });
    }

    // Add a tag
    async function addTag(id, tag) {
      document.removeEventListener('click', closeAutocompleteOnOutsideClick);
      currentAutocompleteId = null;

      const rec = recommendations.find(r => r.id === id);
      if (!rec) return;

      tag = tag.trim().toLowerCase();
      const tags = rec.tags || [];
      if (tags.includes(tag)) {
        renderTable();
        return;
      }

      const newTags = [...tags, tag];
      await fetch(`/api/recommendations/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tags: newTags })
      });

      rec.tags = newTags;
      updateTagFilter();
      renderTable();
      showToast('Tag added');
    }

    // Remove a tag
    async function removeTag(id, tag) {
      const rec = recommendations.find(r => r.id === id);
      if (!rec || !rec.tags) return;

      const newTags = rec.tags.filter(t => t !== tag);
      await fetch(`/api/recommendations/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tags: newTags })
      });

      rec.tags = newTags;
      updateTagFilter();
      renderTable();
      showToast('Tag removed');
    }

    // Hide recommendation
    async function hideRec(id) {
      await fetch(`/api/recommendations/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ hidden: true })
      });

      const rec = recommendations.find(r => r.id === id);
      if (rec) rec.hidden = true;

      renderTable();
      showToast('Recommendation hidden');
    }

    // Restore recommendation
    async function restoreRec(id) {
      await fetch(`/api/recommendations/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ hidden: false })
      });

      const rec = recommendations.find(r => r.id === id);
      if (rec) rec.hidden = false;

      renderTable();
      showToast('Recommendation restored');
    }

    // Toggle selection
    function toggleSelect(id) {
      if (selectedIds.has(id)) {
        selectedIds.delete(id);
      } else {
        selectedIds.add(id);
      }
      updateBulkActions();
      renderTable();
    }

    // Update bulk actions visibility
    function updateBulkActions() {
      if (selectedIds.size > 0) {
        bulkActions.classList.add('visible');
        selectedCount.textContent = `${selectedIds.size} selected`;
      } else {
        bulkActions.classList.remove('visible');
      }
    }

    // Select all visible
    selectAll.addEventListener('change', () => {
      const checkboxes = tableBody.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb => {
        const row = cb.closest('tr');
        const id = parseInt(row.dataset.id);
        if (selectAll.checked) {
          selectedIds.add(id);
        } else {
          selectedIds.delete(id);
        }
      });
      updateBulkActions();
      renderTable();
    });

    // Bulk apply category
    document.getElementById('bulk-apply').addEventListener('click', async () => {
      const category = bulkCategory.value;
      if (!category || selectedIds.size === 0) return;

      await fetch('/api/recommendations/bulk-update', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ids: [...selectedIds], category })
      });

      selectedIds.forEach(id => {
        const rec = recommendations.find(r => r.id === id);
        if (rec) rec.category = category;
      });

      selectedIds.clear();
      updateBulkActions();
      renderTable();
      showToast(`Updated ${selectedIds.size} items`);
    });

    // Bulk hide
    document.getElementById('bulk-hide').addEventListener('click', async () => {
      if (selectedIds.size === 0) return;

      for (const id of selectedIds) {
        await fetch(`/api/recommendations/${id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ hidden: true })
        });

        const rec = recommendations.find(r => r.id === id);
        if (rec) rec.hidden = true;
      }

      selectedIds.clear();
      updateBulkActions();
      renderTable();
      showToast('Items hidden');
    });

    // Filters
    let debounceTimer;
    searchInput.addEventListener('input', () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(renderTable, 200);
    });
    categoryFilter.addEventListener('change', renderTable);
    issueFilter.addEventListener('change', renderTable);
    tagFilter.addEventListener('change', renderTable);
    showHidden.addEventListener('change', renderTable);
    showDeadOnly.addEventListener('change', renderTable);

    // Helpers
    function truncate(str, len) {
      if (!str) return '';
      return str.length > len ? str.slice(0, len) + '...' : str;
    }

    function escapeHtml(str) {
      if (!str) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    function extractDomain(url) {
      try {
        return new URL(url).hostname.replace('www.', '');
      } catch {
        return '';
      }
    }

    function showToast(msg) {
      toast.textContent = msg;
      toast.classList.add('visible');
      setTimeout(() => toast.classList.remove('visible'), 2000);
    }

    // Init
    loadData();
  </script>
</body>
</html>
